// Original location: ./arch/x86_64/cpu/interrupts.h
// Original extension: h

#pragma once
#include <stdint.h>

// This structure represents the CPU state saved on the stack by an interrupt or syscall.
// The order of fields MUST EXACTLY match the order of `push` operations in the
// corresponding assembly handlers.
//
// Stack layout from low address to high address:
// [r15, r14, ..., rax, int_no, err_code, rip, cs, rflags, rsp, ss]
//
// Assembly Push Order: push err_code, THEN push int_no.
// This means int_no is at a lower memory address than err_code.
struct interrupt_frame {
    // General purpose registers pushed by our assembly stubs.
    // This order is the REVERSE of the push order (push rax...push r15).
    uint64_t r15;
    uint64_t r14;
    uint64_t r13;
    uint64_t r12;
    uint64_t r11;
    uint64_t r10;
    uint64_t r9;
    uint64_t r8;
    uint64_t rbp;
    uint64_t rdi;
    uint64_t rsi;
    uint64_t rdx;
    uint64_t rcx;
    uint64_t rbx;
    uint64_t rax;

    // --- THE DEFINITIVE FIX ---
    // The assembly pushes `int_no` LAST, so it is at the lowest address.
    // Therefore, it must come FIRST in the C struct definition.
    uint64_t int_no;
    uint64_t err_code;

    // Pushed automatically by the CPU on interrupt/exception
    uint64_t rip;
    uint64_t cs;
    uint64_t rflags;
    uint64_t rsp;
    uint64_t ss;
};

/**
 * @brief Main C interrupt handler
 * Called by assembly stubs for all interrupts
 * @param frame Pointer to the interrupt stack frame
 */
void interrupt_handler(struct interrupt_frame *frame);

/**
 * @brief Initialize IRQ handling
 * Remaps the PIC and enables interrupts
 */
void irq_init(void);