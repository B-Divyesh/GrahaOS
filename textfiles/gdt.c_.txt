// Original location: ./arch/x86_64/cpu/gdt.c
// Original extension: c

#include "gdt.h"
#include "../mm/pmm.h"
#include "../mm/vmm.h"

// --- GDT is now larger ---
// 0: NULL
// 1: Kernel Code
// 2: Kernel Data
// 3: User Code
// 4: User Data
// 5,6: TSS (takes 2 entries)
#define GDT_ENTRIES 7

static struct gdt_entry gdt[GDT_ENTRIES];
static struct gdt_ptr gdt_pointer;
static struct tss kernel_tss;

// External assembly functions
extern void gdt_load(struct gdt_ptr *gdt_ptr);
extern void tss_load(uint16_t selector); // New function to load the TSS

// Helper function to set up a GDT entry
static void gdt_set_gate(int num, uint8_t access, uint8_t granularity) {
    // In x86_64 long mode, base and limit are ignored for code/data segments
    gdt[num].base_low    = 0x0000;
    gdt[num].base_middle = 0x00;
    gdt[num].base_high   = 0x00;
    gdt[num].limit_low   = 0x0000;
    gdt[num].granularity = granularity;
    gdt[num].access      = access;
}

// --- NEW: Helper to set the TSS gate ---
static void gdt_set_tss(int num, uint64_t base, uint16_t limit, uint8_t access) {
    struct tss_entry *tss_desc = (struct tss_entry *)&gdt[num];
    tss_desc->limit_low = limit & 0xFFFF;
    tss_desc->base_low = base & 0xFFFF;
    tss_desc->base_mid1 = (base >> 16) & 0xFF;
    tss_desc->access = access;
    tss_desc->limit_high_and_flags = ((limit >> 16) & 0x0F) | 0x00; // Granularity is 0 for TSS
    tss_desc->base_mid2 = (base >> 24) & 0xFF;
    tss_desc->base_high = (base >> 32) & 0xFFFFFFFF;
    tss_desc->reserved = 0;
}

void gdt_init(void) {
    // Set up GDT pointer
    gdt_pointer.limit = (sizeof(struct gdt_entry) * GDT_ENTRIES) - 1;
    gdt_pointer.base  = (uint64_t)&gdt;

    // Entry 0: NULL descriptor (required by x86 architecture)
    gdt_set_gate(0, 0x00, 0x00);
    
    // Entry 1: Kernel Code Segment (0x08)
    // Access: 0x9A = Present, Ring 0, Code segment, Executable, Readable
    // Granularity: 0xAF = 4KB granularity, 64-bit code segment
    gdt_set_gate(1, 0x9A, 0xAF);
    
    // Entry 2: Kernel Data Segment (0x10)
    // Access: 0x92 = Present, Ring 0, Data segment, Writable
    // Granularity: 0xCF = 4KB granularity, 32-bit operands
    gdt_set_gate(2, 0x92, 0xCF);

    // --- NEW: User mode gates ---
    // Entry 3: User Code (0x18) - Note the DPL is 3 (0b11)
    gdt_set_gate(3, 0xFA, 0xAF); // Access: 1111 1010b (Present, DPL=3, Exec, Readable)
    
    // Entry 4: User Data (0x20)
    gdt_set_gate(4, 0xF2, 0xCF); // Access: 1111 0010b (Present, DPL=3, Writable)

    // --- NEW: TSS setup ---
    // Allocate a stack for the TSS to use when coming from user mode.
    void *tss_stack = (void*)((uint64_t)pmm_alloc_page() + g_hhdm_offset + 4096);
    if (!tss_stack) {
        // Handle error - for now just halt
        asm volatile ("cli; hlt");
    }
    
    // Initialize TSS structure
    kernel_tss.rsp0 = (uint64_t)tss_stack;
    kernel_tss.rsp1 = 0;
    kernel_tss.rsp2 = 0;
    kernel_tss.reserved0 = 0;
    kernel_tss.reserved1 = 0;
    kernel_tss.ist1 = 0;
    kernel_tss.ist2 = 0;
    kernel_tss.ist3 = 0;
    kernel_tss.ist4 = 0;
    kernel_tss.ist5 = 0;
    kernel_tss.ist6 = 0;
    kernel_tss.ist7 = 0;
    kernel_tss.reserved2 = 0;
    kernel_tss.reserved3 = 0;
    kernel_tss.iopb_offset = sizeof(struct tss);
    
    // Set the TSS descriptor in the GDT
    gdt_set_tss(5, (uint64_t)&kernel_tss, sizeof(kernel_tss) - 1, 0x89); // Access: 1000 1001b (Present, DPL=0, TSS)

    // Load GDT and then TSS
    gdt_load(&gdt_pointer);
    tss_load(0x28); // Selector for TSS is 0x28 (5 * 8)
}