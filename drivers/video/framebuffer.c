/* drivers/video/framebuffer.c */
#include "framebuffer.h"
#include "../../kernel/limine.h"
#include "../../kernel/sync/spinlock.h"

// --- Private Variables ---
static struct limine_framebuffer *fb = NULL;
static uint32_t *fb_addr = NULL;
static uint32_t fb_pitch = 0;
static uint32_t fb_width = 0;
static uint32_t fb_height = 0;
// Framebuffer spinlock - static initialization
spinlock_t fb_lock = SPINLOCK_INITIALIZER("framebuffer");
// --- Simple 8x16 Bitmap Font ---
// Basic ASCII characters (32-126)
static const uint8_t font_8x16[95][16] = {
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+0020 (space)
	{0x00,0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00}, // U+0021 (!)
	{0x00,0x00,0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+0022 (")
	{0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00}, // U+0023 (#)
	{0x00,0x00,0x18,0x3E,0x60,0x3C,0x06,0x7C,0x60,0x3E,0x18,0x00,0x00,0x00,0x00,0x00}, // U+0024 ($)
	{0x00,0x00,0x00,0x00,0x62,0x66,0x0C,0x18,0x30,0x66,0x46,0x00,0x00,0x00,0x00,0x00}, // U+0025 (%)
	{0x00,0x00,0x00,0x3C,0x66,0x66,0x3C,0x6E,0x66,0x66,0x66,0x3C,0x6C,0x00,0x00,0x00}, // U+0026 (&)
	{0x00,0x00,0x00,0x18,0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+0027 (')
	{0x00,0x00,0x06,0x0C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x0C,0x06,0x00,0x00,0x00}, // U+0028 (()
	{0x00,0x00,0x60,0x30,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x30,0x60,0x00,0x00,0x00}, // U+0029 ())
	{0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00}, // U+002A (*)
	{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00}, // U+002B (+)
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x0C,0x00,0x00,0x00}, // U+002C (,)
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+002D (-)
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, // U+002E (.)
	{0x00,0x00,0x02,0x06,0x0C,0x18,0x30,0x60,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+002F (/)
	{0x00,0x00,0x00,0x3C,0x66,0x6E,0x76,0x7E,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0030 (0)
	{0x00,0x00,0x00,0x18,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00}, // U+0031 (1)
	{0x00,0x00,0x00,0x3C,0x66,0x06,0x0C,0x18,0x30,0x60,0x66,0x7E,0x00,0x00,0x00,0x00}, // U+0032 (2)
	{0x00,0x00,0x00,0x3C,0x66,0x06,0x06,0x3C,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0033 (3)
	{0x00,0x00,0x00,0x0C,0x1C,0x3C,0x6C,0x6C,0x7E,0x0C,0x0C,0x0C,0x00,0x00,0x00,0x00}, // U+0034 (4)
	{0x00,0x00,0x00,0x7E,0x60,0x60,0x7C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0035 (5)
	{0x00,0x00,0x00,0x3C,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0036 (6)
	{0x00,0x00,0x00,0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, // U+0037 (7)
	{0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0038 (8)
	{0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x3E,0x06,0x06,0x0C,0x38,0x00,0x00,0x00,0x00}, // U+0039 (9)
	{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // U+003A (:)
	{0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x0C,0x00,0x00,0x00,0x00}, // U+003B (;)
	{0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00}, // U+003C (<)
	{0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+003D (=)
	{0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00}, // U+003E (>)
	{0x00,0x00,0x00,0x3C,0x66,0x06,0x0C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, // U+003F (?)
	{0x00,0x00,0x00,0x3C,0x66,0x66,0x6E,0x6E,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0040 (@)
	{0x00,0x00,0x00,0x18,0x3C,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,0x00,0x00,0x00}, // U+0041 (A)
	{0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00}, // U+0042 (B)
	{0x00,0x00,0x00,0x3C,0x66,0x60,0x60,0x60,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0043 (C)
	{0x00,0x00,0x00,0x78,0x6C,0x66,0x66,0x66,0x66,0x66,0x6C,0x78,0x00,0x00,0x00,0x00}, // U+0044 (D)
	{0x00,0x00,0x00,0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00}, // U+0045 (E)
	{0x00,0x00,0x00,0x7E,0x60,0x60,0x7C,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00}, // U+0046 (F)
	{0x00,0x00,0x00,0x3C,0x66,0x60,0x60,0x6E,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0047 (G)
	{0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00}, // U+0048 (H)
	{0x00,0x00,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00}, // U+0049 (I)
	{0x00,0x00,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+004A (J)
	{0x00,0x00,0x00,0x66,0x6C,0x78,0x70,0x7C,0x70,0x78,0x6C,0x66,0x00,0x00,0x00,0x00}, // U+004B (K)
	{0x00,0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00}, // U+004C (L)
	{0x00,0x00,0x00,0xC6,0xEE,0xFE,0xD6,0xC6,0xC6,0xC6,0xC6,0xC6,0x00,0x00,0x00,0x00}, // U+004D (M)
	{0x00,0x00,0x00,0x66,0x66,0xE6,0xF6,0xDE,0xCE,0x66,0x66,0x66,0x00,0x00,0x00,0x00}, // U+004E (N)
	{0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+004F (O)
	{0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00}, // U+0050 (P)
	{0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x6E,0x3C,0x06,0x0E,0x00,0x00,0x00}, // U+0051 (Q)
	{0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x78,0x6C,0x66,0x66,0x00,0x00,0x00,0x00}, // U+0052 (R)
	{0x00,0x00,0x00,0x3C,0x66,0x60,0x3C,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // U+0053 (S)
	{0x00,0x00,0x00,0x7E,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, // U+0054 (T)
	{0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00}, // U+0055 (U)
	{0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,0x00}, // U+0056 (V)
	{0x00,0x00,0x00,0xC6,0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0x6C,0x00,0x00,0x00,0x00,0x00}, // U+0057 (W)
	{0x00,0x00,0x00,0x66,0x66,0x3C,0x18,0x18,0x3C,0x66,0x66,0x66,0x00,0x00,0x00,0x00}, // U+0058 (X)
	{0x00,0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00}, // U+0059 (Y)
	{0x00,0x00,0x00,0x7E,0x06,0x0C,0x18,0x30,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00}, // U+005A (Z)
	{0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00}, // U+005B ([)
	{0x00,0x00,0x40,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+005C (\)
	{0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00}, // U+005D (])
	{0x00,0x00,0x00,0x18,0x3C,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+005E (^)
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00}, // U+005F (_)
	{0x00,0x00,0x0C,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+0060 (`)
	{0x00,0x00,0x00,0x00,0x00,0x3C,0x06,0x3E,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00}, // U+0061 (a)
	{0x00,0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,0x00}, // U+0062 (b)
	{0x00,0x00,0x00,0x00,0x00,0x3C,0x60,0x60,0x60,0x60,0x3C,0x00,0x00,0x00,0x00,0x00}, // U+0063 (c)
	{0x00,0x00,0x00,0x06,0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00}, // U+0064 (d)
	{0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x7E,0x60,0x60,0x3C,0x00,0x00,0x00,0x00,0x00}, // U+0065 (e)
	{0x00,0x00,0x00,0x1C,0x36,0x30,0x30,0x7C,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00}, // U+0066 (f)
	{0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,0x00,0x00,0x00}, // U+0067 (g)
	{0x00,0x00,0x00,0x60,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // U+0068 (h)
	{0x00,0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00}, // U+0069 (i)
	{0x00,0x00,0x00,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x0C,0x0C,0xCC,0x78,0x00,0x00,0x00}, // U+006A (j)
	{0x00,0x00,0x00,0x60,0x60,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00,0x00,0x00,0x00,0x00}, // U+006B (k)
	{0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,0x00}, // U+006C (l)
	{0x00,0x00,0x00,0x00,0x00,0xCC,0xFE,0xD6,0xD6,0xD6,0xC6,0x00,0x00,0x00,0x00,0x00}, // U+006D (m)
	{0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // U+006E (n)
	{0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00}, // U+006F (o)
	{0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00,0x00,0x00,0x00}, // U+0070 (p)
	{0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06,0x0E,0x00,0x00,0x00,0x00}, // U+0071 (q)
	{0x00,0x00,0x00,0x00,0x00,0x6C,0x76,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00}, // U+0072 (r)
	{0x00,0x00,0x00,0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00,0x00,0x00,0x00,0x00,0x00}, // U+0073 (s)
	{0x00,0x00,0x00,0x10,0x10,0x3C,0x10,0x10,0x10,0x16,0x0C,0x00,0x00,0x00,0x00,0x00}, // U+0074 (t)
	{0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00}, // U+0075 (u)
	{0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,0x00,0x00}, // U+0076 (v)
	{0x00,0x00,0x00,0x00,0x00,0xC6,0xC6,0xD6,0xFE,0x6C,0x00,0x00,0x00,0x00,0x00,0x00}, // U+0077 (w)
	{0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00,0x00,0x00,0x00,0x00}, // U+0078 (x)
	{0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x3E,0x06,0x0C,0x78,0x00,0x00,0x00,0x00,0x00}, // U+0079 (y)
	{0x00,0x00,0x00,0x00,0x00,0x7E,0x0C,0x18,0x30,0x60,0x7E,0x00,0x00,0x00,0x00,0x00}, // U+007A (z)
	{0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,0x00}, // U+007B ({)
	{0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00}, // U+007C (|)
	{0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,0x00}, // U+007D (})
	{0x00,0x00,0x00,0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // U+007E (~)
    // Add more characters as needed...
    // For now, let's include the essential ones for "GrahaOS!"

    // G (71) - but we need to calculate index: 'G' = 71, 71-32 = 39
    [39] = {0x00,0x00,0x3C,0x66,0x60,0x60,0x6E,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // r (114) - 114-32 = 82
    [82] = {0x00,0x00,0x00,0x00,0x00,0x6E,0x76,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00},
    // a (97) - 97-32 = 65
    [65] = {0x00,0x00,0x00,0x00,0x00,0x3C,0x06,0x3E,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00},
    // h (104) - 104-32 = 72
    [72] = {0x00,0x00,0x60,0x60,0x60,0x6C,0x76,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // O (79) - 79-32 = 47
    [47] = {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // S (83) - 83-32 = 51
    [51] = {0x00,0x00,0x3C,0x66,0x60,0x30,0x18,0x0C,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // ! (33) - already defined above
    // P (80) - 80-32 = 48
    [48] = {0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00},
    // 1 (49) - 49-32 = 17
    [17] = {0x00,0x00,0x18,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,0x00},
    // : (58) - 58-32 = 26
    [26] = {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // (space already defined)
    // K (75) - 75-32 = 43
    [43] = {0x00,0x00,0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
};

// --- Helper Functions ---
static size_t strlen(const char *str) {
    if (!str) return 0;
    size_t len = 0;
    while (str[len]) len++;
    return len;
}

static bool is_valid_coordinates(uint32_t x, uint32_t y) {
    return (x < fb_width && y < fb_height);
}

// Internal drawing functions (no locking)
static void _draw_pixel_unsafe(uint32_t x, uint32_t y, uint32_t color) {
    if (is_valid_coordinates(x, y)) {
        fb_addr[y * (fb_pitch / 4) + x] = color;
    }
}

static void _draw_rect_unsafe(uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t color) {
    uint32_t x_end = (x + width < fb_width) ? x + width : fb_width;
    uint32_t y_end = (y + height < fb_height) ? y + height : fb_height;
    
    for (uint32_t j = y; j < y_end; j++) {
        for (uint32_t i = x; i < x_end; i++) {
            fb_addr[j * (fb_pitch / 4) + i] = color;
        }
    }
}

static void _draw_char_unsafe(char c, uint32_t x, uint32_t y, uint32_t fg_color) {
    if (c < 32 || c > 126) return;

    const uint8_t *glyph = font_8x16[c - 32];

    for (int row = 0; row < 16; row++) {
        for (int col = 0; col < 8; col++) {
            if (glyph[row] & (0x80 >> col)) {
                _draw_pixel_unsafe(x + col, y + row, fg_color);
            }
        }
    }
}

// Check if we're in interrupt context
static bool in_interrupt_context(void) {
    // Check if interrupts are disabled - likely in interrupt handler
    uint64_t flags;
    asm volatile("pushfq; pop %0" : "=r"(flags));
    return !(flags & 0x200);  // IF flag
}

// Non-locking versions for use in interrupt handlers
void framebuffer_draw_string_nolock(const char *str, uint32_t x, uint32_t y, 
                                    uint32_t fg_color, uint32_t bg_color) {
    if (!str || !fb_addr) return;
    
    size_t len = strlen(str);
    if (len == 0) return;
    
    // Draw directly without any locking
    // This is safe only if called from interrupt context where nothing else can run
    _draw_rect_unsafe(x, y, len * 8, 16, bg_color);
    
    for (size_t i = 0; i < len; i++) {
        _draw_char_unsafe(str[i], x + (i * 8), y, fg_color);
    }
    
    // Memory barrier to ensure writes complete
    asm volatile("mfence" ::: "memory");
}


// Public functions
bool framebuffer_init(volatile struct limine_framebuffer_request *fb_request) {
    if (!fb_request || !fb_request->response ||
        fb_request->response->framebuffer_count < 1) {
        return false;
    }

    fb = fb_request->response->framebuffers[0];
    fb_addr = (uint32_t *)fb->address;
    fb_pitch = fb->pitch;
    fb_width = fb->width;
    fb_height = fb->height;
    
    // Reinitialize the lock (even though it's statically initialized)
    spinlock_init(&fb_lock, "framebuffer");

    return true;
}

uint32_t framebuffer_get_width(void) {
    return fb_width;
}

uint32_t framebuffer_get_height(void) {
    return fb_height;
}

void framebuffer_draw_pixel(uint32_t x, uint32_t y, uint32_t color) {
    spinlock_acquire(&fb_lock);
    _draw_pixel_unsafe(x, y, color);
    spinlock_release(&fb_lock);
}

void framebuffer_draw_rect(uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t color) {
    if (x >= fb_width || y >= fb_height || width == 0 || height == 0) {
        return;
    }
    
    // Check if in interrupt context
    if (in_interrupt_context()) {
        // Draw without lock
        _draw_rect_unsafe(x, y, width, height, color);
        return;
    }
    
    // Normal path with lock
    spinlock_acquire(&fb_lock);
    _draw_rect_unsafe(x, y, width, height, color);
    spinlock_release(&fb_lock);
}

void framebuffer_draw_rect_outline(uint32_t x, uint32_t y, uint32_t width, uint32_t height, uint32_t color) {
    if (x >= fb_width || y >= fb_height || width == 0 || height == 0) {
        return;
    }
    
    spinlock_acquire(&fb_lock);
    
    // Top and bottom edges
    for (uint32_t i = x; i < x + width && i < fb_width; i++) {
        _draw_pixel_unsafe(i, y, color);
        if (y + height - 1 < fb_height) {
            _draw_pixel_unsafe(i, y + height - 1, color);
        }
    }

    // Left and right edges
    for (uint32_t j = y + 1; j < y + height - 1 && j < fb_height; j++) {
        _draw_pixel_unsafe(x, j, color);
        if (x + width - 1 < fb_width) {
            _draw_pixel_unsafe(x + width - 1, j, color);
        }
    }
    
    spinlock_release(&fb_lock);
}

void framebuffer_draw_char(char c, uint32_t x, uint32_t y, uint32_t fg_color) {
    spinlock_acquire(&fb_lock);
    _draw_char_unsafe(c, x, y, fg_color);
    spinlock_release(&fb_lock);
}

// Modified main framebuffer_draw_string function
void framebuffer_draw_string(const char *str, uint32_t x, uint32_t y, 
                             uint32_t fg_color, uint32_t bg_color) {
    if (!str || !fb_addr) return;
    
    // Check if we're in interrupt context
    if (in_interrupt_context()) {
        // In interrupt - use non-locking version
        framebuffer_draw_string_nolock(str, x, y, fg_color, bg_color);
        return;
    }
    
    // Normal context - use locking
    spinlock_acquire(&fb_lock);
    
    size_t len = strlen(str);
    if (len == 0) {
        spinlock_release(&fb_lock);
        return;
    }
    
    _draw_rect_unsafe(x, y, len * 8, 16, bg_color);
    
    for (size_t i = 0; i < len; i++) {
        _draw_char_unsafe(str[i], x + (i * 8), y, fg_color);
    }
    
    asm volatile("mfence" ::: "memory");
    
    spinlock_release(&fb_lock);
}


void framebuffer_draw_hex(uint64_t value, int x, int y, uint32_t fg_color, uint32_t bg_color) {
    char buffer[19];
    const char *hex_chars = "0123456789ABCDEF";
    
    buffer[0] = '0';
    buffer[1] = 'x';
    
    for (int i = 0; i < 16; i++) {
        uint8_t nibble = (value >> (60 - i * 4)) & 0xF;
        buffer[2 + i] = hex_chars[nibble];
    }
    buffer[18] = '\0';
    
    framebuffer_draw_string(buffer, x, y, fg_color, bg_color);
}

// Clear function with interrupt safety
void framebuffer_clear(uint32_t color) {
    if (in_interrupt_context()) {
        // Clear without lock
        for (uint32_t i = 0; i < fb_width * fb_height; i++) {
            fb_addr[i] = color;
        }
        return;
    }
    
    spinlock_acquire(&fb_lock);
    for (uint32_t i = 0; i < fb_width * fb_height; i++) {
        fb_addr[i] = color;
    }
    spinlock_release(&fb_lock);
}

void framebuffer_draw_rsp_error(uint64_t code) {
    framebuffer_draw_rect(300, 300, 400, 100, COLOR_RED);
    framebuffer_draw_string("ZERO RSP DETECTED!", 320, 320, COLOR_WHITE, COLOR_RED);
    framebuffer_draw_hex(code, 320, 340, COLOR_WHITE, COLOR_RED);
}

// Thread-safe string drawing that doesn't panic on lock issues
void framebuffer_draw_string_safe(const char *str, uint32_t x, uint32_t y, 
                                  uint32_t fg_color, uint32_t bg_color) {
    if (!str || !fb_addr) return;
    
    // Try to acquire lock with timeout
    int attempts = 1000000;
    while (fb_lock.locked && attempts-- > 0) {
        asm volatile("pause");
    }
    
    if (attempts <= 0) {
        // Couldn't get lock - draw without lock (risky but won't crash)
        // This is only for initialization messages
        size_t len = strlen(str);
        if (len == 0) return;
        
        // Draw directly without lock
        for (size_t i = 0; i < len; i++) {
            _draw_char_unsafe(str[i], x + (i * 8), y, fg_color);
        }
        return;
    }
    
    // Got the lock - use normal path
    spinlock_acquire(&fb_lock);
    
    size_t len = strlen(str);
    if (len == 0) {
        spinlock_release(&fb_lock);
        return;
    }
    
    // Draw background
    _draw_rect_unsafe(x, y, len * 8, 16, bg_color);
    
    // Draw characters
    for (size_t i = 0; i < len; i++) {
        _draw_char_unsafe(str[i], x + (i * 8), y, fg_color);
    }
    
    asm volatile("mfence" ::: "memory");
    
    spinlock_release(&fb_lock);
}